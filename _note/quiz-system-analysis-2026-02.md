# 퀴즈 시스템 분석 (2026-02)

## 1. 시니어 프론트엔드 개발자 관점

### 아키텍처 개요

```
진입점                          상태 관리                데이터 레이어             UI
─────                          ───────                ──────────              ──
/quiz (일반)       ──┐
/quiz?quickStart=1 ──┤─→ QuizContent ──→ localStorage ──→ DataRepository ──→ Flashcard
                     │   (page.tsx)      (session-store)   (supabase/dexie)     (4개 평가)
                     │
/wordbooks/[id]/   ──┘─→ PracticePage ──→ (임시 상태) ──→ DataRepository ──→ PracticeFlashcard
  practice               (page.tsx)                        (supabase/dexie)     (3개 우선순위)
```

### 두 가지 학습 모드

| 항목 | SRS 퀴즈 (`/quiz`) | 연습 모드 (`/wordbooks/[id]/practice`) |
|---|---|---|
| 단어 출처 | 전체 복습 대기열 (모든 단어) | 단일 단어장 |
| 알고리즘 | FSRS (ts-fsrs 라이브러리) | 우선순위 가중 랜덤 |
| 결과 | DB에 `StudyProgress` 업데이트 | DB에 `priority` 필드 업데이트 |
| 세션 지속성 | localStorage, 일 단위 | 없음 (임시) |
| 일일 제한 | 있음 (newPerDay + maxReviewsPerDay) | 없음 |
| 카드 타입 | `WordWithProgress` (진행도 포함) | `Word` (진행도 없음) |
| 완료 화면 | SessionReport 화면 | 단순 "완료" 화면 |
| 연속 학습 / 업적 | 있음 | 없음 |

### 잘 된 점

- **Repository 추상화가 탄탄함.** Supabase와 IndexedDB가 `DataRepository` 뒤에 제대로 숨겨져 있음. 퀴즈 페이지는 어떤 백엔드와 통신하는지 전혀 알 필요 없음.
- **세션 복원이 잘 설계됨.** `QuizSessionSnapshot`은 단어 ID만 저장하고(전체 객체가 아닌), 복원 시 최신 데이터를 다시 fetch함. 이로써 오래된 진행 상태가 재적용되는 것을 방지.
- **DOM 이벤트를 통한 복습 대기 카운트 동기화** (`quiz:due-count-refresh`)는 BottomNav를 전역 상태에 끌어들이지 않는 실용적인 대안. 결합도 최소화.

### 발견된 문제

#### P0 — 버그: QuickStart가 일일 새 카드 제한을 무시

`quiz/page.tsx:117-132` — QuickStart는 `settings.newPerDay`를 덱 크기로 사용하지만, 오늘의 `DailyStats.newCount`를 확인하지 않음. 사용자가 이미 일반 SRS로 새 카드 15장을 학습했어도 QuickStart는 20장을 더 제공함. 일일 제한이 무의미해짐.

```typescript
// 현재: 제한 미적용
const take = Math.min(Math.max(settings.newPerDay, 0), all.length);

// 수정 방향:
const stats = await repo.study.getDailyStats();
const remaining = Math.max(0, settings.newPerDay - stats.newCount);
const take = Math.min(remaining, all.length);
```

#### P0 — 버그: 퀴즈의 `handleMaster`가 오래된 인덱스를 남길 수 있음

`quiz/page.tsx:240-251` — `handleMaster`가 현재 단어를 필터링하고 새 배열이 짧아지면 `currentIndex = 0`으로 리셋함. 하지만 `advanceToNext()`를 호출하거나 `showReport`를 트리거하지 않음. 즉:
- 남은 단어가 1개인 상태에서 마스터 처리하면 → `dueWords`가 `[]`가 되고, 리포트가 표시되지 않으며, `completed > 0` 카운트만 있는 "모두 완료" 빈 상태에 멈춤.
- `showReport`가 설정되지 않아 세션 통계(totalReviewed 등)를 잃게 됨.

#### P1 — 데이터: 세션 복원 시 N+1 쿼리 패턴

`quiz/page.tsx:46-60` — `tryRestoreSession`이 모든 단어에 대해 `repo.words.getById(id)`를 개별 호출하고, 이후 모든 단어에 대해 `repo.study.getProgress(w.id)`를 개별 호출함. 20개 단어 세션의 경우, 병렬이긴 하지만 40개의 개별 Supabase RPC 호출이 발생함. `getByIds(ids[])` 배치 메서드가 훨씬 효율적.

#### P1 — 구조: Flashcard와 PracticeFlashcard 간 90%+ 코드 중복

`flashcard.tsx`와 `practice-flashcard.tsx`가 동일한 구조를 공유:
- 동일한 로딩 스켈레톤 패턴
- 동일한 `revealed` 상태 + 탭하여 공개
- 동일한 진행 바
- 동일한 절대 위치 term/reading/meaning 레이아웃
- 동일한 애니메이션 클래스

하단 버튼 행만 다름 (4개 평가 vs 3개 우선순위). 단일 `BaseFlashcard` 컴포넌트에 `renderActions` 슬롯을 두는 것이 적절함.

#### P1 — 상태: 클로저 문제를 위한 `useRef` 동기화 패턴

`practice/page.tsx:37-40` — `handleSetPriority` 내부의 `setTimeout`에서 발생하는 클로저 문제를 해결하기 위해 2개의 `useRef` + `useEffect` 쌍이 존재. 코드 스멜. 300ms 지연을 `flushSync` + callback ref로 처리하거나, 진행 로직을 타이머 기반이 아닌 이벤트 기반으로 변경해야 함.

#### P2 — 미사용 설정: `newCardOrder`

`quiz_settings.new_card_order` (`'recent' | 'priority' | 'jlpt'`)가 저장되고 읽히지만 실제로 소비되지 않음. `getDueWords`는 항상 `selectDueWords`에 위임하고, 이 함수는 자체 고정 점수 공식을 사용함. 설정 UI가 사용자에게 아무 효과 없는 것에 대한 통제 환상을 제공.

#### P2 — 중복 유틸리티: `getLocalDateString`

`session-store.ts:23-29`와 `date-utils.ts` 양쪽에 존재. 동일한 구현. 한쪽이 다른 쪽에서 import 해야 함.

#### P2 — 캐시 무효화 타이밍

`supabase-repo.ts`가 `due_count`를 5초간 캐싱. 하지만 실제 문제는 10초 `daily_stats` 캐시 — 카드 리뷰 후 `getDailyStats()`가 최대 10초 동안 오래된 제한을 반환할 수 있어, 빠른 리뷰 중 후속 `getDueWords` 호출이 제한을 초과할 가능성이 있음.

---

## 2. 언어 학습 전문가 관점

### 잘 된 점

- **FSRS는 올바른 선택.** Again/Hard/Good/Easy 4단계 평가 시스템의 ts-fsrs 구현은 근거 기반이며 충분히 연구된 방식. SM-2보다 기억 유지 효율이 높음.
- **연습과 SRS의 분리가 올바름.** 연습(우선순위 분류)과 SRS(간격 반복)는 서로 다른 인지 기능을 수행하므로 병합되어서는 안 됨:
  - 연습 = **분류** (어떤 단어에 더 관심을 기울여야 하나?)
  - SRS = **스케줄링** (이 단어를 언제 다시 봐야 하나?)
- **Again 시 자동 우선순위 상향** (`quality === 0 → priority = 1`)은 현명한 설계. 두 시스템이 독립적임에도 SRS 실패와 연습 우선순위 간 피드백 루프를 생성.

### 심각한 설계 문제

#### 문제 1: 연습 모드가 교육학적으로 빈약

현재 연습 모드는 정확히 한 가지만 수행: 사용자가 우선순위(높음/보통/낮음)를 재할당하는 것. 다음이 없음:
- **능동적 회상 테스트** — 사용자가 탭하여 공개하고, 우선순위를 할당하면 끝. 단어를 실제로 *알고 있었는지*에 대한 자기 평가가 없음.
- **기억 유지 피드백** — 어떤 단어를 올바르게 회상했고 어떤 단어를 못했는지에 대한 데이터 없음.
- **타이핑/생산 연습** — 수용적 인식만(용어 보기 → 의미 공개). 생산적 출력 없음.

연습은 현재 **퀴즈로 위장한 우선순위 분류 도구**일 뿐. 모든 것에 기계적으로 "보통"을 할당하는 사용자는 학습 가치를 전혀 얻지 못함.

**권장:** 우선순위 할당 전에 최소한 이진 자기 평가를 추가: "이 단어를 알았나요?" (예/아니오). 아니오이면 자동으로 우선순위를 높음으로 설정. 이로써 최소한의 피드백 루프가 생성됨.

#### 문제 2: 방향 제어 없음 (의미 → 용어)

두 모드 모두 **인식**만 테스트 (용어 → 의미). 이것은 더 쉬운 방향. 언어 연구에서는 **생산** (의미 → 용어)이 더 어렵지만 더 강한 기억 흔적을 만든다는 것을 일관되게 보여줌 ("바람직한 어려움"). 카드 방향을 뒤집을 방법이 없음.

**권장:** 카드 방향 퀴즈 설정 추가: `앞 → 뒤` 또는 `뒤 → 앞` 또는 `랜덤`. 적은 노력으로 높은 영향을 미치는 개선.

#### 문제 3: 맥락/예문 없음

플래시카드가 보여주는 것: 용어, 읽기, 의미, 노트. 예문이 없음. 맥락 없는 고립된 어휘 학습은 맥락화된 학습보다 기억 유지율이 현저히 낮음 (Nation, 2001). 단 하나의 예문만으로도 다음이 크게 개선됨:
- 여러 의미 구분
- 문법적 사용 패턴 인코딩
- 에피소드 기억 앵커 제공

#### 문제 4: "거머리(Leech)" 감지 없음

FSRS는 `lapses` (카드가 Again으로 돌아간 횟수)를 추적. 높은 실패 횟수의 단어는 **거머리** — 기억되지 않으면서 불균형적으로 많은 복습 시간을 소비하는 카드. Anki는 기본적으로 8회 실패 후 이를 플래그함. 이 시스템에는 거머리 감지나 처리 전략이 없음.

높은 실패 단어에는 더 많은 반복이 아닌 개입이 필요:
- 전용 "어려운 단어" 뷰에 표시
- 연상 기법 제안
- 하위 구성 요소로 분해 제안 (일본어의 경우 한자 분해)

#### 문제 5: 세션 크기가 너무 경직

일반 퀴즈는 정확히 20개의 복습 대기 단어를 가져옴. QuickStart는 `newPerDay` (기본값 20) 사용. 다음에 기반한 적응적 세션 크기 조정이 없음:
- 가용 시간 (사용자가 5분 또는 30분을 원할 수 있음)
- 카드 난이도 분포 (모두 새 카드인 세션은 대부분 복습인 세션보다 훨씬 어려움)
- 과거 세션 완료율

**권장:** 퀴즈 시작 시 사용자가 세션 크기를 선택할 수 있게 함 (10/20/50/전체 대기), 또는 최소한 "세션 크기" 설정을 `newPerDay`와 분리.

#### 문제 6: 정확도 지표가 오해의 소지가 있음

`SessionReport`가 `정확도 = (totalReviewed - againCount) / totalReviewed`를 표시. 이것은 새 카드(Again이 예상되는)와 복습 카드(Again이 실제 망각을 의미하는)를 혼합. 복습 15장 + 새 카드 5장에서의 70% 정확도와 복습 20장에서의 70% 정확도는 매우 다름.

**권장:** "복습 정확도"와 "새 카드 성공률"로 분리하거나, 최소한 정확도 계산에서 새 카드를 제외.

#### 문제 7: 단어 선택에서 인터리빙 없음

`selectDueWords`는 순수하게 점수(과기한 정도 + 우선순위 + JLPT)로 정렬. 이는 사용자가 모든 높은 우선순위 과기한 단어를 먼저 만나고, 그 다음 중간, 그 다음 낮음 순서로 진행됨을 의미. 인터리빙 연구(Rohrer & Taylor, 2007)에 따르면, 세션 내에서 난이도 수준과 카테고리를 혼합하는 것이 순차적 연습보다 더 나은 장기 기억 유지를 제공.

**권장:** 점수 매기기와 선택 후, 최종 덱을 셔플하거나 부분 인터리빙 알고리즘을 적용 (난이도 티어 간 교대).

---

## 3. 요약 매트릭스

| 문제 | 영향 | 노력 | 우선순위 |
|------|------|------|----------|
| QuickStart가 일일 제한 무시 | 버그 | 낮음 | 즉시 수정 |
| handleMaster 오래된 상태 | 버그 | 낮음 | 즉시 수정 |
| 연습에서 회상 테스트 없음 | 학습 품질 | 중간 | 높음 |
| 방향 제어 없음 | 학습 품질 | 낮음 | 높음 |
| Flashcard 컴포넌트 중복 | 유지보수성 | 중간 | 중간 |
| 거머리 감지 | 학습 품질 | 중간 | 중간 |
| 인터리빙 없음 | 학습 품질 | 낮음 | 중간 |
| 오해의 소지 있는 정확도 지표 | UX 명확성 | 낮음 | 중간 |
| N+1 쿼리 패턴 | 성능 | 중간 | 낮음 |
| 미사용 `newCardOrder` 설정 | 죽은 코드 | 낮음 | 낮음 |
| 예문 | 학습 품질 | 높음 (데이터) | 장기 |

두 개의 버그(P0)는 즉시 수정해야 함. 학습 품질 면에서 **방향 제어**가 가장 높은 ROI의 개선 — 적은 노력으로 퀴즈가 활성화하는 인지 프로세스를 근본적으로 변경함.
